// Code generated by protoc-gen-go. DO NOT EDIT.
// source: medifor/v1/pipeline.proto

package mediforproto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DetectionStage int32

const (
	DetectionStage_DETECTION_STAGE_NONE     DetectionStage = 0
	DetectionStage_DETECTION_STAGE_QUEUED   DetectionStage = 1
	DetectionStage_DETECTION_STAGE_CLAIMED  DetectionStage = 2
	DetectionStage_DETECTION_STAGE_FINISHED DetectionStage = 3
)

var DetectionStage_name = map[int32]string{
	0: "DETECTION_STAGE_NONE",
	1: "DETECTION_STAGE_QUEUED",
	2: "DETECTION_STAGE_CLAIMED",
	3: "DETECTION_STAGE_FINISHED",
}

var DetectionStage_value = map[string]int32{
	"DETECTION_STAGE_NONE":     0,
	"DETECTION_STAGE_QUEUED":   1,
	"DETECTION_STAGE_CLAIMED":  2,
	"DETECTION_STAGE_FINISHED": 3,
}

func (x DetectionStage) String() string {
	return proto.EnumName(DetectionStage_name, int32(x))
}

func (DetectionStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{0}
}

type DetectionStatus int32

const (
	DetectionStatus_DETECTION_STATUS_NONE    DetectionStatus = 0
	DetectionStatus_DETECTION_STATUS_SUCCESS DetectionStatus = 1
	DetectionStatus_DETECTION_STATUS_FAILURE DetectionStatus = 2
)

var DetectionStatus_name = map[int32]string{
	0: "DETECTION_STATUS_NONE",
	1: "DETECTION_STATUS_SUCCESS",
	2: "DETECTION_STATUS_FAILURE",
}

var DetectionStatus_value = map[string]int32{
	"DETECTION_STATUS_NONE":    0,
	"DETECTION_STATUS_SUCCESS": 1,
	"DETECTION_STATUS_FAILURE": 2,
}

func (x DetectionStatus) String() string {
	return proto.EnumName(DetectionStatus_name, int32(x))
}

func (DetectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{1}
}

type SortKey int32

const (
	SortKey_SCORE      SortKey = 0
	SortKey_META       SortKey = 1
	SortKey_META_QUERY SortKey = 2
)

var SortKey_name = map[int32]string{
	0: "SCORE",
	1: "META",
	2: "META_QUERY",
}

var SortKey_value = map[string]int32{
	"SCORE":      0,
	"META":       1,
	"META_QUERY": 2,
}

func (x SortKey) String() string {
	return proto.EnumName(SortKey_name, int32(x))
}

func (SortKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{2}
}

type FusionThresholdType int32

const (
	FusionThresholdType_FUSION_NO_THRESHOLD FusionThresholdType = 0
	FusionThresholdType_FUSION_LT_THRESHOLD FusionThresholdType = 1
	FusionThresholdType_FUSION_GT_THRESHOLD FusionThresholdType = 2
)

var FusionThresholdType_name = map[int32]string{
	0: "FUSION_NO_THRESHOLD",
	1: "FUSION_LT_THRESHOLD",
	2: "FUSION_GT_THRESHOLD",
}

var FusionThresholdType_value = map[string]int32{
	"FUSION_NO_THRESHOLD": 0,
	"FUSION_LT_THRESHOLD": 1,
	"FUSION_GT_THRESHOLD": 2,
}

func (x FusionThresholdType) String() string {
	return proto.EnumName(FusionThresholdType_name, int32(x))
}

func (FusionThresholdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{3}
}

type MediaType int32

const (
	MediaType_IMAGE        MediaType = 0
	MediaType_VIDEO        MediaType = 1
	MediaType_FUSION_IMAGE MediaType = 2
	MediaType_FUSION_VIDEO MediaType = 3
)

var MediaType_name = map[int32]string{
	0: "IMAGE",
	1: "VIDEO",
	2: "FUSION_IMAGE",
	3: "FUSION_VIDEO",
}

var MediaType_value = map[string]int32{
	"IMAGE":        0,
	"VIDEO":        1,
	"FUSION_IMAGE": 2,
	"FUSION_VIDEO": 3,
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{4}
}

type DetectionListVerbosity int32

const (
	DetectionListVerbosity_DETECTION_VERBOSITY_FULL    DetectionListVerbosity = 0
	DetectionListVerbosity_DETECTION_VERBOSITY_MINIMAL DetectionListVerbosity = 1
)

var DetectionListVerbosity_name = map[int32]string{
	0: "DETECTION_VERBOSITY_FULL",
	1: "DETECTION_VERBOSITY_MINIMAL",
}

var DetectionListVerbosity_value = map[string]int32{
	"DETECTION_VERBOSITY_FULL":    0,
	"DETECTION_VERBOSITY_MINIMAL": 1,
}

func (x DetectionListVerbosity) String() string {
	return proto.EnumName(DetectionListVerbosity_name, int32(x))
}

func (DetectionListVerbosity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{5}
}

// SortCol identifies the column to sort by and whether to sort in ascending order
// Next tag: 6
type SortCol struct {
	// Column to sort on
	Key SortKey `protobuf:"varint,1,opt,name=key,proto3,enum=mediforproto.SortKey" json:"key,omitempty"`
	// Bool for sorting in ascending order (if false sorts in descending order)
	IsAsc bool `protobuf:"varint,2,opt,name=is_asc,json=isAsc,proto3" json:"is_asc,omitempty"`
	// What type to cast the key into if necessary
	TypeCast string `protobuf:"bytes,3,opt,name=type_cast,json=typeCast,proto3" json:"type_cast,omitempty"`
	// Metadata key to sort by if using metadata
	MetaKey              string   `protobuf:"bytes,4,opt,name=meta_key,json=metaKey,proto3" json:"meta_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortCol) Reset()         { *m = SortCol{} }
func (m *SortCol) String() string { return proto.CompactTextString(m) }
func (*SortCol) ProtoMessage()    {}
func (*SortCol) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{0}
}

func (m *SortCol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SortCol.Unmarshal(m, b)
}
func (m *SortCol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SortCol.Marshal(b, m, deterministic)
}
func (m *SortCol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortCol.Merge(m, src)
}
func (m *SortCol) XXX_Size() int {
	return xxx_messageInfo_SortCol.Size(m)
}
func (m *SortCol) XXX_DiscardUnknown() {
	xxx_messageInfo_SortCol.DiscardUnknown(m)
}

var xxx_messageInfo_SortCol proto.InternalMessageInfo

func (m *SortCol) GetKey() SortKey {
	if m != nil {
		return m.Key
	}
	return SortKey_SCORE
}

func (m *SortCol) GetIsAsc() bool {
	if m != nil {
		return m.IsAsc
	}
	return false
}

func (m *SortCol) GetTypeCast() string {
	if m != nil {
		return m.TypeCast
	}
	return ""
}

func (m *SortCol) GetMetaKey() string {
	if m != nil {
		return m.MetaKey
	}
	return ""
}

// DetectionRequest contains a MediFor detection object as well as a list of
// analytic ids and fusion ids. TODO: if none specified, default to all?
// Next Tag: 9
type DetectionRequest struct {
	// An optional ID for this detection. If not provided, one will be assigned.
	// Must be unique from any other provided ID: a collision will prevent
	// this request from being fulfilled.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// A Detection proto with just the important request parts filled out.
	Request *Detection `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// The analytics to run.
	AnalyticId []string `protobuf:"bytes,2,rep,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	// Fusers to run automatically when all analytics are done.
	FuserId []string `protobuf:"bytes,8,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Tags to apply to this detection. When in doubt, use user_tags instead.
	Tags map[string]string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// User tags to apply to this detection. When in doubt, use this one.
	UserTags map[string]string `protobuf:"bytes,6,rep,name=user_tags,json=userTags,proto3" json:"user_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Metadata table as needed. Pass-through.
	Meta map[string]string `protobuf:"bytes,7,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Timeout in seconds after which an analytic worker will die waiting for the
	// analytic to respond. Default is "no timeout" (0 seconds).
	AnalyticTimeoutSec   int64    `protobuf:"varint,5,opt,name=analytic_timeout_sec,json=analyticTimeoutSec,proto3" json:"analytic_timeout_sec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionRequest) Reset()         { *m = DetectionRequest{} }
func (m *DetectionRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionRequest) ProtoMessage()    {}
func (*DetectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{1}
}

func (m *DetectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionRequest.Unmarshal(m, b)
}
func (m *DetectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionRequest.Marshal(b, m, deterministic)
}
func (m *DetectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionRequest.Merge(m, src)
}
func (m *DetectionRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionRequest.Size(m)
}
func (m *DetectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionRequest proto.InternalMessageInfo

func (m *DetectionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionRequest) GetRequest() *Detection {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DetectionRequest) GetAnalyticId() []string {
	if m != nil {
		return m.AnalyticId
	}
	return nil
}

func (m *DetectionRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *DetectionRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionRequest) GetUserTags() map[string]string {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *DetectionRequest) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DetectionRequest) GetAnalyticTimeoutSec() int64 {
	if m != nil {
		return m.AnalyticTimeoutSec
	}
	return 0
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
type AnalyticDetectionInfo struct {
	// The analytic that produced this result.
	AnalyticId string `protobuf:"bytes,1,opt,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	// Current processing stage for the entire detection event (all analytics) if
	// in progress, or PT_STAGE_FINISHED if completed. When complete, the status
	// field will have a non-default value.
	Stage DetectionStage `protobuf:"varint,2,opt,name=stage,proto3,enum=mediforproto.DetectionStage" json:"stage,omitempty"`
	// Final status when we are in PT_STAGE_FINISHED.
	Status DetectionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=mediforproto.DetectionStatus" json:"status,omitempty"`
	// The Detection with the result and status filled out (and the request).
	// If the response and status are empty (default), then it is not finished.
	Detection            *Detection `protobuf:"bytes,4,opt,name=detection,proto3" json:"detection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AnalyticDetectionInfo) Reset()         { *m = AnalyticDetectionInfo{} }
func (m *AnalyticDetectionInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyticDetectionInfo) ProtoMessage()    {}
func (*AnalyticDetectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{2}
}

func (m *AnalyticDetectionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnalyticDetectionInfo.Unmarshal(m, b)
}
func (m *AnalyticDetectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnalyticDetectionInfo.Marshal(b, m, deterministic)
}
func (m *AnalyticDetectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyticDetectionInfo.Merge(m, src)
}
func (m *AnalyticDetectionInfo) XXX_Size() int {
	return xxx_messageInfo_AnalyticDetectionInfo.Size(m)
}
func (m *AnalyticDetectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyticDetectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyticDetectionInfo proto.InternalMessageInfo

func (m *AnalyticDetectionInfo) GetAnalyticId() string {
	if m != nil {
		return m.AnalyticId
	}
	return ""
}

func (m *AnalyticDetectionInfo) GetStage() DetectionStage {
	if m != nil {
		return m.Stage
	}
	return DetectionStage_DETECTION_STAGE_NONE
}

func (m *AnalyticDetectionInfo) GetStatus() DetectionStatus {
	if m != nil {
		return m.Status
	}
	return DetectionStatus_DETECTION_STATUS_NONE
}

func (m *AnalyticDetectionInfo) GetDetection() *Detection {
	if m != nil {
		return m.Detection
	}
	return nil
}

// DetectionInfo provides details on a given detection event specified by the id.
// Next Tag: 11
type DetectionInfo struct {
	// The detection event ID.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A list of input resources for this detection. Usually a singleton, but can
	// contain multiple if multiple are accepted for this particular kind of
	// request
	ReqResources []*Resource `protobuf:"bytes,11,rep,name=req_resources,json=reqResources,proto3" json:"req_resources,omitempty"`
	// Results for individual analytics.
	AnalyticInfo []*AnalyticDetectionInfo `protobuf:"bytes,2,rep,name=analytic_info,json=analyticInfo,proto3" json:"analytic_info,omitempty"`
	// Results for fusion analytics
	FusionInfo []*FuserFusionInfo `protobuf:"bytes,8,rep,name=fusion_info,json=fusionInfo,proto3" json:"fusion_info,omitempty"`
	// Tags for the requested detection.
	Tags     map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UserTags map[string]string `protobuf:"bytes,6,rep,name=user_tags,json=userTags,proto3" json:"user_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta     map[string]string `protobuf:"bytes,7,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A fused score, if requested.
	HasFused   bool    `protobuf:"varint,4,opt,name=has_fused,json=hasFused,proto3" json:"has_fused,omitempty"`
	FusedScore float64 `protobuf:"fixed64,5,opt,name=fused_score,json=fusedScore,proto3" json:"fused_score,omitempty"`
	// Progress indicator across all analytics.
	AnalyticsTotal       int32    `protobuf:"varint,9,opt,name=analytics_total,json=analyticsTotal,proto3" json:"analytics_total,omitempty"`
	AnalyticsFinished    int32    `protobuf:"varint,10,opt,name=analytics_finished,json=analyticsFinished,proto3" json:"analytics_finished,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionInfo) Reset()         { *m = DetectionInfo{} }
func (m *DetectionInfo) String() string { return proto.CompactTextString(m) }
func (*DetectionInfo) ProtoMessage()    {}
func (*DetectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{3}
}

func (m *DetectionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionInfo.Unmarshal(m, b)
}
func (m *DetectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionInfo.Marshal(b, m, deterministic)
}
func (m *DetectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionInfo.Merge(m, src)
}
func (m *DetectionInfo) XXX_Size() int {
	return xxx_messageInfo_DetectionInfo.Size(m)
}
func (m *DetectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionInfo proto.InternalMessageInfo

func (m *DetectionInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionInfo) GetReqResources() []*Resource {
	if m != nil {
		return m.ReqResources
	}
	return nil
}

func (m *DetectionInfo) GetAnalyticInfo() []*AnalyticDetectionInfo {
	if m != nil {
		return m.AnalyticInfo
	}
	return nil
}

func (m *DetectionInfo) GetFusionInfo() []*FuserFusionInfo {
	if m != nil {
		return m.FusionInfo
	}
	return nil
}

func (m *DetectionInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionInfo) GetUserTags() map[string]string {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *DetectionInfo) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DetectionInfo) GetHasFused() bool {
	if m != nil {
		return m.HasFused
	}
	return false
}

func (m *DetectionInfo) GetFusedScore() float64 {
	if m != nil {
		return m.FusedScore
	}
	return 0
}

func (m *DetectionInfo) GetAnalyticsTotal() int32 {
	if m != nil {
		return m.AnalyticsTotal
	}
	return 0
}

func (m *DetectionInfo) GetAnalyticsFinished() int32 {
	if m != nil {
		return m.AnalyticsFinished
	}
	return 0
}

// DetectionInfoRequest contains the ID of an individual detection event.
type DetectionInfoRequest struct {
	// The ID of the detection, as returned by Detect or GetDetectionList.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// If specified, fused scores will be returned as well.
	WantFused            bool     `protobuf:"varint,2,opt,name=want_fused,json=wantFused,proto3" json:"want_fused,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionInfoRequest) Reset()         { *m = DetectionInfoRequest{} }
func (m *DetectionInfoRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionInfoRequest) ProtoMessage()    {}
func (*DetectionInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{4}
}

func (m *DetectionInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionInfoRequest.Unmarshal(m, b)
}
func (m *DetectionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionInfoRequest.Marshal(b, m, deterministic)
}
func (m *DetectionInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionInfoRequest.Merge(m, src)
}
func (m *DetectionInfoRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionInfoRequest.Size(m)
}
func (m *DetectionInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionInfoRequest proto.InternalMessageInfo

func (m *DetectionInfoRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionInfoRequest) GetWantFused() bool {
	if m != nil {
		return m.WantFused
	}
	return false
}

type DateRange struct {
	// Inclusive start time in seconds since the Epoch UTC.
	StartSecondsUtc int64 `protobuf:"varint,1,opt,name=start_seconds_utc,json=startSecondsUtc,proto3" json:"start_seconds_utc,omitempty"`
	// Inclusive end time in seconds since the Epoch UTC.
	EndSecondsUtc        int64    `protobuf:"varint,2,opt,name=end_seconds_utc,json=endSecondsUtc,proto3" json:"end_seconds_utc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateRange) Reset()         { *m = DateRange{} }
func (m *DateRange) String() string { return proto.CompactTextString(m) }
func (*DateRange) ProtoMessage()    {}
func (*DateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{5}
}

func (m *DateRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DateRange.Unmarshal(m, b)
}
func (m *DateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DateRange.Marshal(b, m, deterministic)
}
func (m *DateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateRange.Merge(m, src)
}
func (m *DateRange) XXX_Size() int {
	return xxx_messageInfo_DateRange.Size(m)
}
func (m *DateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DateRange.DiscardUnknown(m)
}

var xxx_messageInfo_DateRange proto.InternalMessageInfo

func (m *DateRange) GetStartSecondsUtc() int64 {
	if m != nil {
		return m.StartSecondsUtc
	}
	return 0
}

func (m *DateRange) GetEndSecondsUtc() int64 {
	if m != nil {
		return m.EndSecondsUtc
	}
	return 0
}

// Next Tag: 10
type DetectionListRequest struct {
	// How much should be returned? Default: all.
	Verbosity DetectionListVerbosity `protobuf:"varint,12,opt,name=verbosity,proto3,enum=mediforproto.DetectionListVerbosity" json:"verbosity,omitempty"`
	// If specified (can be empty), all listed tags (both key and value) must be
	// simultaneously present for a detection ID to be returned.
	Tags map[string]string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// This contains a "fuzzy meta search" query. It will look through
	// detection metatags for string values that match the given query.
	MetaQuery string `protobuf:"bytes,10,opt,name=meta_query,json=metaQuery,proto3" json:"meta_query,omitempty"`
	// Filter on dates
	// If start time is present (nonzero), all detections must have at least one analytic with a create time >= start.
	// If end time is present (nonzero), all detections must have at least one analytic create time <= end.
	// If either is zero (not present), then the filter is unbounded in that direction.
	DateRange *DateRange `protobuf:"bytes,11,opt,name=date_range,json=dateRange,proto3" json:"date_range,omitempty"`
	// If specified, only returns results from the given list of detection IDs.
	// Good for returning a single detection or one of a few. Not great for very
	// long lists (thousands).
	DetectionIds []string `protobuf:"bytes,7,rep,name=detection_ids,json=detectionIds,proto3" json:"detection_ids,omitempty"`
	// Specify that detection info objects should have fusion scores.
	WantFused bool `protobuf:"varint,4,opt,name=want_fused,json=wantFused,proto3" json:"want_fused,omitempty"`
	// A series of keys to sort on, with the first key being the primary sort key
	// and following ones being seconday, tertiary, etc...
	OrderBy []*SortCol `protobuf:"bytes,5,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// Fusion ID on which to sort by fusion score.
	FuserId string `protobuf:"bytes,6,opt,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Fusion score threshold, if needed. Only used if the threshold type is not the default value (no threshold).
	FusionThresholdType  FusionThresholdType `protobuf:"varint,8,opt,name=fusion_threshold_type,json=fusionThresholdType,proto3,enum=mediforproto.FusionThresholdType" json:"fusion_threshold_type,omitempty"`
	FusionThresholdValue float32             `protobuf:"fixed32,9,opt,name=fusion_threshold_value,json=fusionThresholdValue,proto3" json:"fusion_threshold_value,omitempty"`
	// Maximum number of items in the response. Optional.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// If a token was returned in the response, this can be used to continue
	// where the previous response left off.
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionListRequest) Reset()         { *m = DetectionListRequest{} }
func (m *DetectionListRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionListRequest) ProtoMessage()    {}
func (*DetectionListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{6}
}

func (m *DetectionListRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionListRequest.Unmarshal(m, b)
}
func (m *DetectionListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionListRequest.Marshal(b, m, deterministic)
}
func (m *DetectionListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionListRequest.Merge(m, src)
}
func (m *DetectionListRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionListRequest.Size(m)
}
func (m *DetectionListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionListRequest proto.InternalMessageInfo

func (m *DetectionListRequest) GetVerbosity() DetectionListVerbosity {
	if m != nil {
		return m.Verbosity
	}
	return DetectionListVerbosity_DETECTION_VERBOSITY_FULL
}

func (m *DetectionListRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionListRequest) GetMetaQuery() string {
	if m != nil {
		return m.MetaQuery
	}
	return ""
}

func (m *DetectionListRequest) GetDateRange() *DateRange {
	if m != nil {
		return m.DateRange
	}
	return nil
}

func (m *DetectionListRequest) GetDetectionIds() []string {
	if m != nil {
		return m.DetectionIds
	}
	return nil
}

func (m *DetectionListRequest) GetWantFused() bool {
	if m != nil {
		return m.WantFused
	}
	return false
}

func (m *DetectionListRequest) GetOrderBy() []*SortCol {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *DetectionListRequest) GetFuserId() string {
	if m != nil {
		return m.FuserId
	}
	return ""
}

func (m *DetectionListRequest) GetFusionThresholdType() FusionThresholdType {
	if m != nil {
		return m.FusionThresholdType
	}
	return FusionThresholdType_FUSION_NO_THRESHOLD
}

func (m *DetectionListRequest) GetFusionThresholdValue() float32 {
	if m != nil {
		return m.FusionThresholdValue
	}
	return 0
}

func (m *DetectionListRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *DetectionListRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// DetectionList provides a list of DetectionInfo objects.
// Next Tag: 4
type DetectionList struct {
	Detections []*DetectionInfo `protobuf:"bytes,1,rep,name=detections,proto3" json:"detections,omitempty"`
	// Total detections in the filtered list.
	Total int32 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	// If this is non-empty, there are more results to be returned. Pass it into
	// a DetectionListRequest to obtain remaining results.
	PageToken            string   `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionList) Reset()         { *m = DetectionList{} }
func (m *DetectionList) String() string { return proto.CompactTextString(m) }
func (*DetectionList) ProtoMessage()    {}
func (*DetectionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{7}
}

func (m *DetectionList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionList.Unmarshal(m, b)
}
func (m *DetectionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionList.Marshal(b, m, deterministic)
}
func (m *DetectionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionList.Merge(m, src)
}
func (m *DetectionList) XXX_Size() int {
	return xxx_messageInfo_DetectionList.Size(m)
}
func (m *DetectionList) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionList.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionList proto.InternalMessageInfo

func (m *DetectionList) GetDetections() []*DetectionInfo {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *DetectionList) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DetectionList) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// FusionRequest contains a fusion object or a list of detectionIDs to be fused.
// Next ID: 7
type FusionRequest struct {
	// An optional ID for this fusion. If not provided, one will be assigned.
	// Must be unique from any other provided ID: a collision will prevent
	// this request from being fulfilled.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A Fusion Proto containing the original probe as well as the detection objects from
	// each analytic that ran over that probe.
	Request *Fusion `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// IDs for the fusion analytics
	FuserId []string `protobuf:"bytes,4,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Tags to apply to this fusion.  To be inserted into the database as json.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// DetectionID for the probes on which to perform fusion if no request is specified
	DetectionId string `protobuf:"bytes,5,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	// Output directory to use ONLY if building request from a detection ID
	DetectionIdOutDir    string   `protobuf:"bytes,6,opt,name=detection_id_out_dir,json=detectionIdOutDir,proto3" json:"detection_id_out_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FusionRequest) Reset()         { *m = FusionRequest{} }
func (m *FusionRequest) String() string { return proto.CompactTextString(m) }
func (*FusionRequest) ProtoMessage()    {}
func (*FusionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{8}
}

func (m *FusionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FusionRequest.Unmarshal(m, b)
}
func (m *FusionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FusionRequest.Marshal(b, m, deterministic)
}
func (m *FusionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FusionRequest.Merge(m, src)
}
func (m *FusionRequest) XXX_Size() int {
	return xxx_messageInfo_FusionRequest.Size(m)
}
func (m *FusionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FusionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FusionRequest proto.InternalMessageInfo

func (m *FusionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FusionRequest) GetRequest() *Fusion {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FusionRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *FusionRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FusionRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func (m *FusionRequest) GetDetectionIdOutDir() string {
	if m != nil {
		return m.DetectionIdOutDir
	}
	return ""
}

// AnalyticDetectionInfo provides details on the status of a detection being
// performed by a given analytic.
// Next ID: 5
type FuserFusionInfo struct {
	// The fusion algorithmc that produced this result.
	FuserId string `protobuf:"bytes,1,opt,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// Current processing stage for the entire detection event (all analytics) if
	// in progress, or PT_STAGE_FINISHED if completed. When complete, the status
	// field will have a non-default value.
	Stage DetectionStage `protobuf:"varint,2,opt,name=stage,proto3,enum=mediforproto.DetectionStage" json:"stage,omitempty"`
	// Final status when we are in PT_STAGE_FINISHED.
	Status DetectionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=mediforproto.DetectionStatus" json:"status,omitempty"`
	// The Fusion with the result and status filled out (and the request).
	// If the response and status are empty (default), then it is not finished.
	Fusion               *Fusion  `protobuf:"bytes,4,opt,name=fusion,proto3" json:"fusion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuserFusionInfo) Reset()         { *m = FuserFusionInfo{} }
func (m *FuserFusionInfo) String() string { return proto.CompactTextString(m) }
func (*FuserFusionInfo) ProtoMessage()    {}
func (*FuserFusionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{9}
}

func (m *FuserFusionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuserFusionInfo.Unmarshal(m, b)
}
func (m *FuserFusionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuserFusionInfo.Marshal(b, m, deterministic)
}
func (m *FuserFusionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuserFusionInfo.Merge(m, src)
}
func (m *FuserFusionInfo) XXX_Size() int {
	return xxx_messageInfo_FuserFusionInfo.Size(m)
}
func (m *FuserFusionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FuserFusionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FuserFusionInfo proto.InternalMessageInfo

func (m *FuserFusionInfo) GetFuserId() string {
	if m != nil {
		return m.FuserId
	}
	return ""
}

func (m *FuserFusionInfo) GetStage() DetectionStage {
	if m != nil {
		return m.Stage
	}
	return DetectionStage_DETECTION_STAGE_NONE
}

func (m *FuserFusionInfo) GetStatus() DetectionStatus {
	if m != nil {
		return m.Status
	}
	return DetectionStatus_DETECTION_STATUS_NONE
}

func (m *FuserFusionInfo) GetFusion() *Fusion {
	if m != nil {
		return m.Fusion
	}
	return nil
}

// FusionInfo provides details on a given fusion event specified by the ID.
type FusionInfo struct {
	// Fusion event ID.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Results for individual fusion analytics.
	FusionInfos []*FuserFusionInfo `protobuf:"bytes,2,rep,name=fusion_infos,json=fusionInfos,proto3" json:"fusion_infos,omitempty"`
	// Tags for the requested fusion.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A fused score, if requested.
	HasFused             bool     `protobuf:"varint,4,opt,name=has_fused,json=hasFused,proto3" json:"has_fused,omitempty"`
	FusedScore           float64  `protobuf:"fixed64,5,opt,name=fused_score,json=fusedScore,proto3" json:"fused_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FusionInfo) Reset()         { *m = FusionInfo{} }
func (m *FusionInfo) String() string { return proto.CompactTextString(m) }
func (*FusionInfo) ProtoMessage()    {}
func (*FusionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{10}
}

func (m *FusionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FusionInfo.Unmarshal(m, b)
}
func (m *FusionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FusionInfo.Marshal(b, m, deterministic)
}
func (m *FusionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FusionInfo.Merge(m, src)
}
func (m *FusionInfo) XXX_Size() int {
	return xxx_messageInfo_FusionInfo.Size(m)
}
func (m *FusionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FusionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FusionInfo proto.InternalMessageInfo

func (m *FusionInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FusionInfo) GetFusionInfos() []*FuserFusionInfo {
	if m != nil {
		return m.FusionInfos
	}
	return nil
}

func (m *FusionInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FusionInfo) GetHasFused() bool {
	if m != nil {
		return m.HasFused
	}
	return false
}

func (m *FusionInfo) GetFusedScore() float64 {
	if m != nil {
		return m.FusedScore
	}
	return 0
}

type FuseAllIDsRequest struct {
	FuserId              []string `protobuf:"bytes,1,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	OutDir               string   `protobuf:"bytes,2,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseAllIDsRequest) Reset()         { *m = FuseAllIDsRequest{} }
func (m *FuseAllIDsRequest) String() string { return proto.CompactTextString(m) }
func (*FuseAllIDsRequest) ProtoMessage()    {}
func (*FuseAllIDsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{11}
}

func (m *FuseAllIDsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseAllIDsRequest.Unmarshal(m, b)
}
func (m *FuseAllIDsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseAllIDsRequest.Marshal(b, m, deterministic)
}
func (m *FuseAllIDsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseAllIDsRequest.Merge(m, src)
}
func (m *FuseAllIDsRequest) XXX_Size() int {
	return xxx_messageInfo_FuseAllIDsRequest.Size(m)
}
func (m *FuseAllIDsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseAllIDsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FuseAllIDsRequest proto.InternalMessageInfo

func (m *FuseAllIDsRequest) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *FuseAllIDsRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

type FuseAllIDsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuseAllIDsResponse) Reset()         { *m = FuseAllIDsResponse{} }
func (m *FuseAllIDsResponse) String() string { return proto.CompactTextString(m) }
func (*FuseAllIDsResponse) ProtoMessage()    {}
func (*FuseAllIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{12}
}

func (m *FuseAllIDsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FuseAllIDsResponse.Unmarshal(m, b)
}
func (m *FuseAllIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FuseAllIDsResponse.Marshal(b, m, deterministic)
}
func (m *FuseAllIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuseAllIDsResponse.Merge(m, src)
}
func (m *FuseAllIDsResponse) XXX_Size() int {
	return xxx_messageInfo_FuseAllIDsResponse.Size(m)
}
func (m *FuseAllIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FuseAllIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FuseAllIDsResponse proto.InternalMessageInfo

// UpdateDetectionTagsRequest contains new tags to replace or merge with existing tags.
// Next Tag: 5
type UpdateDetectionTagsRequest struct {
	// The detection ID to update.
	DetectionId string `protobuf:"bytes,1,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	// If true, replaces all user tags with the given tag set. Default is to
	// merge (replacing any duplicates, but leaving unmentioned tag keys alone).
	// Ignores delete_tags if set.
	Replace bool `protobuf:"varint,2,opt,name=replace,proto3" json:"replace,omitempty"`
	// Tags to use in the request. Only updates user tags, not bare system tags.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Tag keys to delete. Only used if replace is false.
	DeleteTags           []string `protobuf:"bytes,4,rep,name=delete_tags,json=deleteTags,proto3" json:"delete_tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDetectionTagsRequest) Reset()         { *m = UpdateDetectionTagsRequest{} }
func (m *UpdateDetectionTagsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateDetectionTagsRequest) ProtoMessage()    {}
func (*UpdateDetectionTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{13}
}

func (m *UpdateDetectionTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Unmarshal(m, b)
}
func (m *UpdateDetectionTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Marshal(b, m, deterministic)
}
func (m *UpdateDetectionTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDetectionTagsRequest.Merge(m, src)
}
func (m *UpdateDetectionTagsRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateDetectionTagsRequest.Size(m)
}
func (m *UpdateDetectionTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDetectionTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDetectionTagsRequest proto.InternalMessageInfo

func (m *UpdateDetectionTagsRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func (m *UpdateDetectionTagsRequest) GetReplace() bool {
	if m != nil {
		return m.Replace
	}
	return false
}

func (m *UpdateDetectionTagsRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *UpdateDetectionTagsRequest) GetDeleteTags() []string {
	if m != nil {
		return m.DeleteTags
	}
	return nil
}

// DetectionTagInfoRequest asks for high-level information about detection tags.
type DetectionTagInfoRequest struct {
	// If specified, only tags that coexist with the given required tags will
	// be returned. One possible use of this is to limit tags returned by login
	// group.
	RequireTags map[string]string `protobuf:"bytes,1,rep,name=require_tags,json=requireTags,proto3" json:"require_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If specified, all keys prefixed with any value in this list will
	// not be returned in the result.
	SkipPrefixes         []string `protobuf:"bytes,2,rep,name=skip_prefixes,json=skipPrefixes,proto3" json:"skip_prefixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionTagInfoRequest) Reset()         { *m = DetectionTagInfoRequest{} }
func (m *DetectionTagInfoRequest) String() string { return proto.CompactTextString(m) }
func (*DetectionTagInfoRequest) ProtoMessage()    {}
func (*DetectionTagInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{14}
}

func (m *DetectionTagInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionTagInfoRequest.Unmarshal(m, b)
}
func (m *DetectionTagInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionTagInfoRequest.Marshal(b, m, deterministic)
}
func (m *DetectionTagInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionTagInfoRequest.Merge(m, src)
}
func (m *DetectionTagInfoRequest) XXX_Size() int {
	return xxx_messageInfo_DetectionTagInfoRequest.Size(m)
}
func (m *DetectionTagInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionTagInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionTagInfoRequest proto.InternalMessageInfo

func (m *DetectionTagInfoRequest) GetRequireTags() map[string]string {
	if m != nil {
		return m.RequireTags
	}
	return nil
}

func (m *DetectionTagInfoRequest) GetSkipPrefixes() []string {
	if m != nil {
		return m.SkipPrefixes
	}
	return nil
}

// DetectionTagInfo contains high-level information about detection tags.
type DetectionTagInfo struct {
	// Contains mapping from "key=value" to number of times that specific key/value pair is found.
	TagCounts map[string]int32 `protobuf:"bytes,1,rep,name=tag_counts,json=tagCounts,proto3" json:"tag_counts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Contains mapping from "key=value" in *user tags* to number of times they appear.
	// Note that this can have overlap with system tags, and it will report these separately.
	UserTagCounts        map[string]int32 `protobuf:"bytes,2,rep,name=user_tag_counts,json=userTagCounts,proto3" json:"user_tag_counts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DetectionTagInfo) Reset()         { *m = DetectionTagInfo{} }
func (m *DetectionTagInfo) String() string { return proto.CompactTextString(m) }
func (*DetectionTagInfo) ProtoMessage()    {}
func (*DetectionTagInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{15}
}

func (m *DetectionTagInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionTagInfo.Unmarshal(m, b)
}
func (m *DetectionTagInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionTagInfo.Marshal(b, m, deterministic)
}
func (m *DetectionTagInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionTagInfo.Merge(m, src)
}
func (m *DetectionTagInfo) XXX_Size() int {
	return xxx_messageInfo_DetectionTagInfo.Size(m)
}
func (m *DetectionTagInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionTagInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionTagInfo proto.InternalMessageInfo

func (m *DetectionTagInfo) GetTagCounts() map[string]int32 {
	if m != nil {
		return m.TagCounts
	}
	return nil
}

func (m *DetectionTagInfo) GetUserTagCounts() map[string]int32 {
	if m != nil {
		return m.UserTagCounts
	}
	return nil
}

type DeleteDetectionRequest struct {
	DetectionId          string   `protobuf:"bytes,1,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDetectionRequest) Reset()         { *m = DeleteDetectionRequest{} }
func (m *DeleteDetectionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDetectionRequest) ProtoMessage()    {}
func (*DeleteDetectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{16}
}

func (m *DeleteDetectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteDetectionRequest.Unmarshal(m, b)
}
func (m *DeleteDetectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteDetectionRequest.Marshal(b, m, deterministic)
}
func (m *DeleteDetectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDetectionRequest.Merge(m, src)
}
func (m *DeleteDetectionRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteDetectionRequest.Size(m)
}
func (m *DeleteDetectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDetectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDetectionRequest proto.InternalMessageInfo

func (m *DeleteDetectionRequest) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

// AnalyticMeta containes analytic metadata defining which analytics are currently active
// on the system, what they do, and their resource requirements
type AnalyticMeta struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version              string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Cpu                  float64           `protobuf:"fixed64,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Ram                  float64           `protobuf:"fixed64,4,opt,name=ram,proto3" json:"ram,omitempty"`
	Gpu                  int32             `protobuf:"varint,5,opt,name=gpu,proto3" json:"gpu,omitempty"`
	Media                []MediaType       `protobuf:"varint,6,rep,packed,name=media,proto3,enum=mediforproto.MediaType" json:"media,omitempty"`
	Description          string            `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Name                 string            `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
	UserFields           map[string]string `protobuf:"bytes,9,rep,name=user_fields,json=userFields,proto3" json:"user_fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnalyticMeta) Reset()         { *m = AnalyticMeta{} }
func (m *AnalyticMeta) String() string { return proto.CompactTextString(m) }
func (*AnalyticMeta) ProtoMessage()    {}
func (*AnalyticMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{17}
}

func (m *AnalyticMeta) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnalyticMeta.Unmarshal(m, b)
}
func (m *AnalyticMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnalyticMeta.Marshal(b, m, deterministic)
}
func (m *AnalyticMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyticMeta.Merge(m, src)
}
func (m *AnalyticMeta) XXX_Size() int {
	return xxx_messageInfo_AnalyticMeta.Size(m)
}
func (m *AnalyticMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyticMeta.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyticMeta proto.InternalMessageInfo

func (m *AnalyticMeta) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnalyticMeta) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AnalyticMeta) GetCpu() float64 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *AnalyticMeta) GetRam() float64 {
	if m != nil {
		return m.Ram
	}
	return 0
}

func (m *AnalyticMeta) GetGpu() int32 {
	if m != nil {
		return m.Gpu
	}
	return 0
}

func (m *AnalyticMeta) GetMedia() []MediaType {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *AnalyticMeta) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AnalyticMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AnalyticMeta) GetUserFields() map[string]string {
	if m != nil {
		return m.UserFields
	}
	return nil
}

// AnalyticList holds a list of AnalyticMeta configuration metadata objects
type AnalyticList struct {
	Analytics            []*AnalyticMeta `protobuf:"bytes,1,rep,name=analytics,proto3" json:"analytics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AnalyticList) Reset()         { *m = AnalyticList{} }
func (m *AnalyticList) String() string { return proto.CompactTextString(m) }
func (*AnalyticList) ProtoMessage()    {}
func (*AnalyticList) Descriptor() ([]byte, []int) {
	return fileDescriptor_49bc7aaef7d70e21, []int{18}
}

func (m *AnalyticList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnalyticList.Unmarshal(m, b)
}
func (m *AnalyticList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnalyticList.Marshal(b, m, deterministic)
}
func (m *AnalyticList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyticList.Merge(m, src)
}
func (m *AnalyticList) XXX_Size() int {
	return xxx_messageInfo_AnalyticList.Size(m)
}
func (m *AnalyticList) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyticList.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyticList proto.InternalMessageInfo

func (m *AnalyticList) GetAnalytics() []*AnalyticMeta {
	if m != nil {
		return m.Analytics
	}
	return nil
}

func init() {
	proto.RegisterEnum("mediforproto.DetectionStage", DetectionStage_name, DetectionStage_value)
	proto.RegisterEnum("mediforproto.DetectionStatus", DetectionStatus_name, DetectionStatus_value)
	proto.RegisterEnum("mediforproto.SortKey", SortKey_name, SortKey_value)
	proto.RegisterEnum("mediforproto.FusionThresholdType", FusionThresholdType_name, FusionThresholdType_value)
	proto.RegisterEnum("mediforproto.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("mediforproto.DetectionListVerbosity", DetectionListVerbosity_name, DetectionListVerbosity_value)
	proto.RegisterType((*SortCol)(nil), "mediforproto.SortCol")
	proto.RegisterType((*DetectionRequest)(nil), "mediforproto.DetectionRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.TagsEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionRequest.UserTagsEntry")
	proto.RegisterType((*AnalyticDetectionInfo)(nil), "mediforproto.AnalyticDetectionInfo")
	proto.RegisterType((*DetectionInfo)(nil), "mediforproto.DetectionInfo")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.TagsEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionInfo.UserTagsEntry")
	proto.RegisterType((*DetectionInfoRequest)(nil), "mediforproto.DetectionInfoRequest")
	proto.RegisterType((*DateRange)(nil), "mediforproto.DateRange")
	proto.RegisterType((*DetectionListRequest)(nil), "mediforproto.DetectionListRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionListRequest.TagsEntry")
	proto.RegisterType((*DetectionList)(nil), "mediforproto.DetectionList")
	proto.RegisterType((*FusionRequest)(nil), "mediforproto.FusionRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.FusionRequest.TagsEntry")
	proto.RegisterType((*FuserFusionInfo)(nil), "mediforproto.FuserFusionInfo")
	proto.RegisterType((*FusionInfo)(nil), "mediforproto.FusionInfo")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.FusionInfo.TagsEntry")
	proto.RegisterType((*FuseAllIDsRequest)(nil), "mediforproto.FuseAllIDsRequest")
	proto.RegisterType((*FuseAllIDsResponse)(nil), "mediforproto.FuseAllIDsResponse")
	proto.RegisterType((*UpdateDetectionTagsRequest)(nil), "mediforproto.UpdateDetectionTagsRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.UpdateDetectionTagsRequest.TagsEntry")
	proto.RegisterType((*DetectionTagInfoRequest)(nil), "mediforproto.DetectionTagInfoRequest")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionTagInfoRequest.RequireTagsEntry")
	proto.RegisterType((*DetectionTagInfo)(nil), "mediforproto.DetectionTagInfo")
	proto.RegisterMapType((map[string]int32)(nil), "mediforproto.DetectionTagInfo.TagCountsEntry")
	proto.RegisterMapType((map[string]int32)(nil), "mediforproto.DetectionTagInfo.UserTagCountsEntry")
	proto.RegisterType((*DeleteDetectionRequest)(nil), "mediforproto.DeleteDetectionRequest")
	proto.RegisterType((*AnalyticMeta)(nil), "mediforproto.AnalyticMeta")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.AnalyticMeta.UserFieldsEntry")
	proto.RegisterType((*AnalyticList)(nil), "mediforproto.AnalyticList")
}

func init() { proto.RegisterFile("medifor/v1/pipeline.proto", fileDescriptor_49bc7aaef7d70e21) }

var fileDescriptor_49bc7aaef7d70e21 = []byte{
	// 1986 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x73, 0xdb, 0xc6,
	0x15, 0x0f, 0x40, 0x51, 0x22, 0x1e, 0x29, 0x89, 0x5e, 0x49, 0x16, 0x4c, 0xc5, 0xb1, 0xc2, 0x34,
	0x8d, 0xaa, 0x89, 0xe5, 0x58, 0x6d, 0x9c, 0xa4, 0x4e, 0x32, 0xa6, 0x44, 0x50, 0xe2, 0x98, 0x12,
	0x93, 0x25, 0xe9, 0x8e, 0x67, 0x32, 0x83, 0xc2, 0xc4, 0x52, 0xc2, 0x98, 0x02, 0x68, 0xec, 0xc2,
	0x2d, 0x73, 0xcb, 0xa5, 0xb7, 0x7e, 0x83, 0x7e, 0x8a, 0xde, 0x3a, 0x3d, 0xf7, 0x43, 0xb4, 0x97,
	0x9e, 0xfb, 0x19, 0x7a, 0xe9, 0xec, 0x2e, 0x00, 0x02, 0xe0, 0x1f, 0x59, 0xea, 0x4c, 0x67, 0x7a,
	0xc3, 0xbe, 0xf7, 0xf6, 0xed, 0xfb, 0xbf, 0xbf, 0x05, 0xdc, 0xbb, 0x22, 0xb6, 0x33, 0xf0, 0xfc,
	0x47, 0x6f, 0x1f, 0x3f, 0x1a, 0x39, 0x23, 0x32, 0x74, 0x5c, 0x72, 0x30, 0xf2, 0x3d, 0xe6, 0xa1,
	0x52, 0xc8, 0x12, 0xab, 0x4a, 0x52, 0xd0, 0x72, 0xad, 0xe1, 0x98, 0x39, 0x7d, 0x29, 0x58, 0xd9,
	0x4e, 0xb0, 0x06, 0x01, 0x75, 0x3c, 0x57, 0x32, 0xaa, 0x3f, 0x29, 0xb0, 0xd2, 0xf1, 0x7c, 0x76,
	0xec, 0x0d, 0xd1, 0x27, 0x90, 0x7b, 0x4d, 0xc6, 0xba, 0xb2, 0xab, 0xec, 0xad, 0x1d, 0x6e, 0x1d,
	0x24, 0x75, 0x1f, 0x70, 0x99, 0xe7, 0x64, 0x8c, 0xb9, 0x04, 0xda, 0x82, 0x65, 0x87, 0x9a, 0x16,
	0xed, 0xeb, 0xea, 0xae, 0xb2, 0x57, 0xc0, 0x79, 0x87, 0xd6, 0x68, 0x1f, 0xed, 0x80, 0xc6, 0xc6,
	0x23, 0x62, 0xf6, 0x2d, 0xca, 0xf4, 0xdc, 0xae, 0xb2, 0xa7, 0xe1, 0x02, 0x27, 0x1c, 0x5b, 0x94,
	0xa1, 0x7b, 0x50, 0xb8, 0x22, 0xcc, 0x32, 0xf9, 0x09, 0x4b, 0x82, 0xb7, 0xc2, 0xd7, 0xcf, 0xc9,
	0xb8, 0xfa, 0x97, 0x25, 0x28, 0xd7, 0x09, 0x23, 0x7d, 0xe6, 0x78, 0x2e, 0x26, 0x6f, 0x02, 0x42,
	0x19, 0x5a, 0x03, 0xd5, 0xb1, 0x43, 0x2d, 0xaa, 0x63, 0xa3, 0xc7, 0xb0, 0xe2, 0x4b, 0x96, 0x30,
	0xb0, 0x78, 0xb8, 0x9d, 0x36, 0x70, 0xa2, 0x20, 0x92, 0x43, 0x0f, 0xa0, 0x18, 0x85, 0xc1, 0x74,
	0x6c, 0x5d, 0xdd, 0xcd, 0xed, 0x69, 0x18, 0x22, 0x52, 0xd3, 0xe6, 0x36, 0x0d, 0x02, 0x4a, 0x7c,
	0xce, 0x2d, 0x08, 0xee, 0x8a, 0x58, 0x37, 0x6d, 0xf4, 0x35, 0x2c, 0x31, 0xeb, 0x82, 0xea, 0x4b,
	0xbb, 0xb9, 0xbd, 0xe2, 0xe1, 0xde, 0xbc, 0xb3, 0xe4, 0x49, 0x07, 0x5d, 0xeb, 0x82, 0x1a, 0x2e,
	0xf3, 0xc7, 0x58, 0xec, 0x42, 0x4d, 0xd0, 0x84, 0x5e, 0xa1, 0x62, 0x59, 0xa8, 0xf8, 0xf4, 0x1a,
	0x15, 0x3d, 0x4a, 0xfc, 0x89, 0x9a, 0x42, 0x10, 0x2e, 0xb9, 0x21, 0x3c, 0x4e, 0xfa, 0xca, 0x3b,
	0x19, 0x72, 0x46, 0x98, 0x15, 0x1a, 0xc2, 0x77, 0xa1, 0xcf, 0x60, 0x33, 0x0e, 0x01, 0x73, 0xae,
	0x88, 0x17, 0x30, 0x93, 0x92, 0xbe, 0x9e, 0xdf, 0x55, 0xf6, 0x72, 0x18, 0x45, 0xbc, 0xae, 0x64,
	0x75, 0x48, 0xbf, 0xf2, 0x05, 0x68, 0xb1, 0x19, 0xa8, 0x3c, 0xa9, 0x08, 0x4d, 0xa6, 0x7e, 0x13,
	0xf2, 0x6f, 0xad, 0x61, 0x40, 0x44, 0xe6, 0x35, 0x2c, 0x17, 0xbf, 0x56, 0xbf, 0x54, 0x2a, 0x4f,
	0x61, 0x35, 0xe5, 0xc3, 0x8d, 0x36, 0x7f, 0x01, 0x5a, 0x6c, 0xfa, 0x4d, 0x36, 0x56, 0xff, 0xa1,
	0xc0, 0x56, 0x2d, 0xf4, 0x22, 0x8e, 0x46, 0xd3, 0x1d, 0x78, 0xd9, 0xec, 0x4b, 0x6d, 0xc9, 0xec,
	0x1f, 0x42, 0x9e, 0x32, 0xeb, 0x42, 0x2a, 0x5d, 0x3b, 0x7c, 0x7f, 0x4e, 0x68, 0x3b, 0x5c, 0x06,
	0x4b, 0x51, 0xf4, 0x39, 0x2c, 0x53, 0x66, 0xb1, 0x80, 0x8a, 0xca, 0x5c, 0x3b, 0xbc, 0x3f, 0x7f,
	0x13, 0x0b, 0x28, 0x0e, 0x85, 0xd1, 0xe7, 0xa0, 0xd9, 0x11, 0x4b, 0x54, 0xff, 0x82, 0xf2, 0x9d,
	0x48, 0x56, 0xff, 0x95, 0x87, 0xd5, 0xb4, 0x53, 0xb2, 0x2b, 0x94, 0xb8, 0x2b, 0x9e, 0xc2, 0xaa,
	0x4f, 0xde, 0x98, 0x3e, 0xa1, 0x5e, 0xe0, 0xf7, 0x09, 0xd5, 0x8b, 0xa2, 0x4c, 0xee, 0xa6, 0x95,
	0xe3, 0x90, 0x8d, 0x4b, 0x3e, 0x79, 0x13, 0x2d, 0x28, 0x3a, 0x85, 0xd5, 0x49, 0x84, 0xdc, 0x81,
	0x27, 0x3a, 0xa4, 0x78, 0xf8, 0x51, 0x7a, 0xf3, 0xcc, 0xe8, 0xe2, 0x52, 0x1c, 0x48, 0x6e, 0xd6,
	0xb7, 0x50, 0x94, 0x53, 0x45, 0xea, 0x29, 0x08, 0x3d, 0x99, 0xd8, 0x34, 0x78, 0x49, 0x37, 0x84,
	0x94, 0xd0, 0x00, 0x83, 0xf8, 0x1b, 0x7d, 0x15, 0x76, 0x5b, 0x4e, 0x6c, 0xfc, 0x78, 0x4e, 0x68,
	0xb8, 0xe8, 0x54, 0xab, 0x35, 0xa6, 0x5b, 0xed, 0x17, 0x8b, 0xf6, 0xcf, 0xeb, 0xb3, 0xaf, 0x52,
	0x7d, 0xb6, 0xd0, 0x84, 0x6c, 0x93, 0xed, 0x80, 0x76, 0x69, 0x51, 0x93, 0x8f, 0x0e, 0x5b, 0x64,
	0xb7, 0x80, 0x0b, 0x97, 0x16, 0xe5, 0x0e, 0xdb, 0xbc, 0x0c, 0x05, 0xc3, 0xa4, 0x7d, 0xcf, 0x27,
	0xa2, 0xf1, 0x14, 0xe1, 0x3b, 0xb1, 0x3b, 0x9c, 0x82, 0x3e, 0x81, 0xf5, 0x28, 0x96, 0xd4, 0x64,
	0x1e, 0xb3, 0x86, 0xba, 0xb6, 0xab, 0xec, 0xe5, 0xf1, 0x5a, 0x4c, 0xee, 0x72, 0x2a, 0x7a, 0x08,
	0x68, 0x22, 0x38, 0x70, 0x5c, 0x87, 0x5e, 0x12, 0x5b, 0x07, 0x21, 0x7b, 0x27, 0xe6, 0x34, 0x42,
	0xc6, 0xff, 0x5b, 0x23, 0x1b, 0xb0, 0x99, 0xae, 0xb0, 0xd4, 0x3d, 0x30, 0xa9, 0xf8, 0xfb, 0x00,
	0xbf, 0xb3, 0x5c, 0x16, 0x46, 0x5b, 0xde, 0x3f, 0x1a, 0xa7, 0x88, 0x70, 0x57, 0x4d, 0xd0, 0xea,
	0x16, 0x23, 0xd8, 0x72, 0x2f, 0x08, 0xda, 0x87, 0x3b, 0x94, 0x59, 0xbe, 0x18, 0x79, 0x9e, 0x6b,
	0x53, 0x33, 0x60, 0x7d, 0xa1, 0x2a, 0x87, 0xd7, 0x05, 0xa3, 0x23, 0xe9, 0x3d, 0xd6, 0x47, 0x3f,
	0x87, 0x75, 0xe2, 0xda, 0x29, 0x49, 0x55, 0x48, 0xae, 0x12, 0xd7, 0x9e, 0xc8, 0x55, 0xff, 0x90,
	0x4f, 0x18, 0xda, 0x72, 0x28, 0x8b, 0x0c, 0x3d, 0x02, 0xed, 0x2d, 0xf1, 0x5f, 0x79, 0xd4, 0x61,
	0x63, 0xbd, 0x24, 0xa6, 0xc3, 0xcf, 0xe6, 0x54, 0x11, 0xdf, 0xf6, 0x22, 0x92, 0xc5, 0x93, 0x6d,
	0xe8, 0x59, 0xd8, 0x07, 0xca, 0xc2, 0x2b, 0x23, 0x71, 0xea, 0x54, 0x3b, 0xdc, 0x07, 0x10, 0xd7,
	0xec, 0x9b, 0x80, 0xf8, 0x63, 0x51, 0x1c, 0x1a, 0xd6, 0x38, 0xe5, 0x7b, 0x4e, 0x40, 0x4f, 0x00,
	0x6c, 0x8b, 0x11, 0xd3, 0xe7, 0xf1, 0xd1, 0x8b, 0x33, 0x27, 0x51, 0x14, 0x3e, 0xac, 0xd9, 0x71,
	0x24, 0x3f, 0x82, 0xd5, 0x78, 0x2c, 0x99, 0x8e, 0x4d, 0x45, 0x9b, 0x68, 0xb8, 0x14, 0x13, 0x9b,
	0x36, 0xcd, 0xa4, 0x66, 0x29, 0x93, 0x1a, 0xf4, 0x19, 0x14, 0x3c, 0xdf, 0x26, 0xbe, 0xf9, 0x6a,
	0xac, 0xe7, 0x85, 0x83, 0x33, 0x30, 0xc6, 0xb1, 0x37, 0xc4, 0x2b, 0x42, 0xec, 0x68, 0x9c, 0xba,
	0x9f, 0x97, 0x25, 0x66, 0x88, 0xee, 0xe7, 0x1e, 0x6c, 0x85, 0x13, 0x87, 0x5d, 0xfa, 0x84, 0x5e,
	0x7a, 0x43, 0xdb, 0xe4, 0x58, 0x43, 0x2f, 0x88, 0xc8, 0x7f, 0x38, 0x35, 0x7b, 0x1c, 0xcf, 0xed,
	0x46, 0x92, 0xdd, 0xf1, 0x88, 0xe0, 0x8d, 0xc1, 0x34, 0x11, 0xfd, 0x0a, 0xee, 0x4e, 0xa9, 0x95,
	0x05, 0xcb, 0x7b, 0x52, 0xc5, 0x9b, 0x99, 0x4d, 0x2f, 0x38, 0x8f, 0x0f, 0x80, 0x91, 0x75, 0x41,
	0x4c, 0xea, 0xfc, 0x28, 0x2b, 0x3b, 0x8f, 0x0b, 0x9c, 0xd0, 0x71, 0x7e, 0x24, 0x3c, 0x2a, 0x82,
	0xc9, 0xbc, 0xd7, 0xc4, 0x0d, 0x01, 0x8d, 0x10, 0xef, 0x72, 0xc2, 0xad, 0xdb, 0x94, 0x23, 0xb7,
	0xd5, 0x54, 0x49, 0xa0, 0xa7, 0x00, 0x71, 0x3e, 0xa2, 0x1a, 0xda, 0x59, 0x30, 0xc8, 0x70, 0x42,
	0x9c, 0x1f, 0x24, 0x87, 0x4f, 0x4e, 0xd8, 0x2f, 0x17, 0x19, 0xe3, 0xd5, 0x8c, 0xf1, 0xd5, 0x3f,
	0xab, 0xb0, 0x2a, 0x63, 0x3b, 0xaf, 0x5d, 0x0f, 0x26, 0xb0, 0x4d, 0x15, 0xd5, 0xb6, 0x39, 0x2b,
	0x33, 0x13, 0xcc, 0x96, 0x4c, 0xf9, 0x52, 0x1a, 0x92, 0x2d, 0xbc, 0x24, 0x52, 0x56, 0x4c, 0x75,
	0xc5, 0x87, 0x50, 0x4a, 0x96, 0xaf, 0x98, 0xc2, 0x1a, 0x2e, 0x26, 0xaa, 0x17, 0x3d, 0x82, 0xcd,
	0xa4, 0x88, 0xc9, 0x91, 0x92, 0xed, 0xf8, 0x61, 0xdd, 0xdd, 0x49, 0x88, 0xb6, 0x03, 0x56, 0x77,
	0xfc, 0xdb, 0x27, 0xee, 0x6f, 0x0a, 0xac, 0x67, 0x2e, 0xc3, 0x94, 0xdb, 0x4a, 0xba, 0xd2, 0xff,
	0x87, 0x30, 0xe5, 0x53, 0x58, 0x96, 0xf5, 0x1d, 0x62, 0x94, 0xd9, 0xb9, 0x0a, 0x65, 0xaa, 0x7f,
	0x54, 0x01, 0x12, 0x2e, 0x64, 0x33, 0xff, 0x0c, 0x4a, 0x09, 0x4c, 0x40, 0x43, 0x70, 0x71, 0x0d,
	0x28, 0x28, 0x4e, 0x40, 0x01, 0x45, 0x4f, 0x52, 0x09, 0xaf, 0xce, 0x32, 0x66, 0x26, 0x24, 0xf8,
	0xaf, 0xee, 0xe3, 0xdb, 0xe7, 0xf5, 0x04, 0xee, 0xf0, 0x23, 0x6a, 0xc3, 0x61, 0xb3, 0x4e, 0xf1,
	0x8c, 0x7a, 0x56, 0xd2, 0xf5, 0xbc, 0x0d, 0x2b, 0x51, 0x91, 0x49, 0x5d, 0xcb, 0x9e, 0xa8, 0xac,
	0xea, 0x26, 0xa0, 0xa4, 0x22, 0x3a, 0xf2, 0x5c, 0x4a, 0xaa, 0xff, 0x56, 0xa0, 0xd2, 0x1b, 0xf1,
	0x91, 0x1c, 0xa7, 0x8f, 0xdb, 0x19, 0x1d, 0x94, 0x2d, 0x71, 0x65, 0xba, 0xc4, 0x75, 0xde, 0x8b,
	0xa3, 0xa1, 0xd5, 0x27, 0xe1, 0xbd, 0x19, 0x2d, 0x51, 0x23, 0x15, 0xe9, 0xc3, 0x74, 0xa4, 0xe7,
	0x1f, 0x3a, 0x15, 0xf9, 0x07, 0x50, 0xb4, 0xc9, 0x90, 0x30, 0x62, 0xc6, 0x8f, 0x27, 0x8d, 0x4f,
	0x19, 0x4e, 0xe2, 0xb2, 0xb7, 0x0f, 0xee, 0xdf, 0x15, 0xd8, 0x4e, 0x9a, 0x90, 0x84, 0x08, 0x2f,
	0x81, 0xe3, 0xda, 0xc0, 0xf1, 0xc3, 0x63, 0xe5, 0xe4, 0x7b, 0x32, 0xa7, 0xe6, 0xd3, 0x9b, 0x0f,
	0xb0, 0xdc, 0x39, 0xf1, 0xa4, 0xe8, 0x4f, 0x28, 0xfc, 0xde, 0xa3, 0xaf, 0x9d, 0x91, 0x39, 0xf2,
	0xc9, 0xc0, 0xf9, 0x3d, 0xa1, 0xe1, 0x23, 0xb2, 0xc4, 0x89, 0xdf, 0x85, 0xb4, 0xca, 0xb7, 0x50,
	0xce, 0x6a, 0xb9, 0x91, 0x6f, 0x7f, 0x55, 0x13, 0xef, 0xdf, 0xd0, 0x3c, 0xd4, 0x02, 0x60, 0xd6,
	0x85, 0xd9, 0xf7, 0x02, 0x97, 0x45, 0x2e, 0x3d, 0x5c, 0xec, 0x12, 0x4f, 0xc7, 0xb1, 0x90, 0x97,
	0x9e, 0x68, 0x2c, 0x5a, 0xa3, 0x97, 0xb0, 0x1e, 0xa1, 0xe4, 0x48, 0xa5, 0xec, 0xc7, 0xc7, 0xd7,
	0xa8, 0x0c, 0x91, 0x60, 0x52, 0xed, 0x6a, 0x90, 0xa4, 0x55, 0xbe, 0x86, 0xb5, 0xb4, 0xc0, 0x75,
	0xbe, 0xe7, 0x93, 0x78, 0xf1, 0x19, 0xa0, 0xe9, 0x23, 0x6e, 0xa2, 0xa1, 0xfa, 0x14, 0xee, 0xd6,
	0x45, 0x81, 0x4d, 0xfd, 0x42, 0xb8, 0xbe, 0x25, 0xaa, 0xff, 0x54, 0xa1, 0x14, 0x3d, 0x70, 0x38,
	0x6e, 0x9d, 0x9a, 0x62, 0x3a, 0xac, 0xbc, 0x25, 0xbe, 0x98, 0x89, 0x32, 0x6f, 0xd1, 0x92, 0xdb,
	0xd8, 0x1f, 0x05, 0x62, 0xc0, 0x2a, 0x98, 0x7f, 0x72, 0x8a, 0x6f, 0x5d, 0x89, 0x89, 0xa3, 0x60,
	0xfe, 0xc9, 0x29, 0x17, 0xa3, 0x40, 0x0c, 0x99, 0x3c, 0xe6, 0x9f, 0xe8, 0x21, 0xe4, 0x79, 0xc0,
	0x2d, 0xf1, 0x54, 0x59, 0xcb, 0x62, 0xaf, 0x33, 0xce, 0x12, 0xe8, 0x44, 0x4a, 0xa1, 0x5d, 0xde,
	0x50, 0xb4, 0xef, 0x3b, 0x23, 0xf1, 0x74, 0x5c, 0x89, 0x3c, 0x88, 0x49, 0x08, 0xc1, 0x92, 0x6b,
	0x5d, 0x49, 0xdc, 0xa3, 0x61, 0xf1, 0x8d, 0x9e, 0x43, 0x51, 0x64, 0x7b, 0xe0, 0x90, 0xa1, 0x4d,
	0x75, 0x4d, 0x64, 0x7a, 0x7f, 0xf6, 0xb3, 0x8e, 0x7b, 0x2d, 0xb2, 0xdc, 0x10, 0xc2, 0x32, 0xc5,
	0x10, 0xc4, 0x84, 0xca, 0x37, 0xb0, 0x9e, 0x61, 0xdf, 0xa8, 0xb8, 0x4f, 0x27, 0x01, 0x16, 0x20,
	0xe5, 0x4b, 0xd0, 0xe2, 0xb7, 0x4a, 0x58, 0xd6, 0x95, 0xf9, 0x96, 0xe1, 0x89, 0xf0, 0xfe, 0x4f,
	0x0a, 0xac, 0xa5, 0xaf, 0x3b, 0xa4, 0xc3, 0x66, 0xdd, 0xe8, 0x1a, 0xc7, 0xdd, 0x66, 0xfb, 0xdc,
	0xec, 0x74, 0x6b, 0x27, 0x86, 0x79, 0xde, 0x3e, 0x37, 0xca, 0xef, 0xa1, 0x0a, 0xdc, 0xcd, 0x72,
	0xbe, 0xef, 0x19, 0x3d, 0xa3, 0x5e, 0x56, 0xd0, 0x0e, 0x6c, 0x67, 0x79, 0xc7, 0xad, 0x5a, 0xf3,
	0xcc, 0xa8, 0x97, 0x55, 0xf4, 0x3e, 0xe8, 0x59, 0x66, 0xa3, 0x79, 0xde, 0xec, 0x9c, 0x1a, 0xf5,
	0x72, 0x6e, 0xff, 0x12, 0xd6, 0x33, 0x97, 0x27, 0xba, 0x07, 0x5b, 0xa9, 0x0d, 0xdd, 0x5e, 0x27,
	0x32, 0x22, 0xab, 0x8b, 0xb3, 0x3a, 0xbd, 0xe3, 0x63, 0xa3, 0xd3, 0x29, 0x2b, 0x33, 0xb9, 0x8d,
	0x5a, 0xb3, 0xd5, 0xc3, 0x46, 0x59, 0xdd, 0x3f, 0x90, 0xff, 0xe5, 0x9e, 0x93, 0x31, 0xd2, 0x20,
	0xdf, 0x39, 0x6e, 0x63, 0xae, 0xb1, 0x00, 0x4b, 0x67, 0x46, 0xb7, 0x56, 0x56, 0xd0, 0x1a, 0x00,
	0xff, 0xe2, 0x5e, 0xe1, 0x97, 0x65, 0x75, 0xff, 0xb7, 0xb0, 0x31, 0x03, 0xe5, 0xa2, 0x6d, 0xd8,
	0x68, 0xf4, 0x3a, 0xfc, 0x84, 0xf3, 0xb6, 0xd9, 0x3d, 0xc5, 0x46, 0xe7, 0xb4, 0xdd, 0xaa, 0x97,
	0xdf, 0x4b, 0x30, 0x5a, 0xdd, 0x04, 0x43, 0x49, 0x30, 0x4e, 0x92, 0x0c, 0x75, 0xdf, 0xe0, 0x4f,
	0xbb, 0xb0, 0x3e, 0xb9, 0x4d, 0xcd, 0xb3, 0xda, 0x09, 0xb7, 0x49, 0x83, 0xfc, 0x8b, 0x66, 0xdd,
	0x68, 0x97, 0x15, 0x54, 0x86, 0x52, 0xb8, 0x57, 0x32, 0xd5, 0x04, 0x45, 0xca, 0xe4, 0xf6, 0x7f,
	0xc3, 0xfb, 0x75, 0xd6, 0x43, 0x28, 0x1d, 0x90, 0x17, 0x06, 0x3e, 0x6a, 0x77, 0x9a, 0xdd, 0x97,
	0x66, 0xa3, 0xd7, 0x6a, 0x95, 0xdf, 0x43, 0x0f, 0x60, 0x67, 0x16, 0xf7, 0xac, 0x79, 0xde, 0x3c,
	0xab, 0xb5, 0xca, 0xca, 0xe1, 0x9f, 0x96, 0xa1, 0xf0, 0x5d, 0xf8, 0x7f, 0x14, 0x19, 0xb0, 0x2c,
	0x4f, 0x41, 0x1f, 0x2c, 0xfe, 0x65, 0x56, 0x59, 0x84, 0x90, 0x51, 0x07, 0xca, 0x27, 0x84, 0xa5,
	0x69, 0xd5, 0x45, 0x90, 0xfa, 0x16, 0x4a, 0x45, 0x5b, 0x54, 0xaf, 0x7f, 0xeb, 0xcd, 0x55, 0x2a,
	0x14, 0xb4, 0x78, 0x65, 0xa6, 0xc6, 0x20, 0x9a, 0x7a, 0x7e, 0xce, 0x9a, 0x92, 0x95, 0x8d, 0xb4,
	0x94, 0x71, 0x35, 0x62, 0x63, 0xf4, 0x0d, 0x2c, 0x71, 0x08, 0x82, 0x76, 0x16, 0xa0, 0xec, 0x8a,
	0x3e, 0x0f, 0x91, 0xa1, 0x1a, 0x14, 0xf8, 0xf6, 0xa3, 0x71, 0xb3, 0x7e, 0x5b, 0x15, 0x6d, 0x01,
	0x2e, 0x43, 0x10, 0x84, 0x1e, 0x4c, 0xc3, 0xc6, 0x14, 0xce, 0xaa, 0xec, 0xce, 0x17, 0x90, 0xf8,
	0x09, 0xfd, 0x00, 0x1b, 0x33, 0x90, 0x0c, 0xda, 0x7b, 0x57, 0xb0, 0xb3, 0x38, 0xa7, 0x3f, 0xc0,
	0x46, 0x32, 0xa7, 0xd1, 0x2d, 0xfe, 0xf1, 0x3b, 0x81, 0x90, 0xca, 0x07, 0x8b, 0xc5, 0xd0, 0x11,
	0xac, 0x9f, 0x10, 0x96, 0xba, 0xa8, 0x66, 0xa5, 0xad, 0x32, 0x67, 0x92, 0xf2, 0x02, 0x79, 0xb5,
	0x2c, 0x68, 0xbf, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x60, 0x57, 0x9c, 0x4f, 0x18,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PipelineClient is the client API for Pipeline service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PipelineClient interface {
	Detect(ctx context.Context, in *DetectionRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionInfo(ctx context.Context, in *DetectionInfoRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionList(ctx context.Context, in *DetectionListRequest, opts ...grpc.CallOption) (*DetectionList, error)
	DeleteDetection(ctx context.Context, in *DeleteDetectionRequest, opts ...grpc.CallOption) (*Empty, error)
	Fuse(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error)
	FuseByID(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error)
	FuseAllIDs(ctx context.Context, in *FuseAllIDsRequest, opts ...grpc.CallOption) (*FuseAllIDsResponse, error)
	UpdateDetectionTags(ctx context.Context, in *UpdateDetectionTagsRequest, opts ...grpc.CallOption) (*DetectionInfo, error)
	GetDetectionTagInfo(ctx context.Context, in *DetectionTagInfoRequest, opts ...grpc.CallOption) (*DetectionTagInfo, error)
	GetAnalyticMeta(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AnalyticList, error)
}

type pipelineClient struct {
	cc *grpc.ClientConn
}

func NewPipelineClient(cc *grpc.ClientConn) PipelineClient {
	return &pipelineClient{cc}
}

func (c *pipelineClient) Detect(ctx context.Context, in *DetectionRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionInfo(ctx context.Context, in *DetectionInfoRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionList(ctx context.Context, in *DetectionListRequest, opts ...grpc.CallOption) (*DetectionList, error) {
	out := new(DetectionList)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) DeleteDetection(ctx context.Context, in *DeleteDetectionRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/DeleteDetection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) Fuse(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error) {
	out := new(FusionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/Fuse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) FuseByID(ctx context.Context, in *FusionRequest, opts ...grpc.CallOption) (*FusionInfo, error) {
	out := new(FusionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/FuseByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) FuseAllIDs(ctx context.Context, in *FuseAllIDsRequest, opts ...grpc.CallOption) (*FuseAllIDsResponse, error) {
	out := new(FuseAllIDsResponse)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/FuseAllIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) UpdateDetectionTags(ctx context.Context, in *UpdateDetectionTagsRequest, opts ...grpc.CallOption) (*DetectionInfo, error) {
	out := new(DetectionInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/UpdateDetectionTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetDetectionTagInfo(ctx context.Context, in *DetectionTagInfoRequest, opts ...grpc.CallOption) (*DetectionTagInfo, error) {
	out := new(DetectionTagInfo)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetDetectionTagInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineClient) GetAnalyticMeta(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AnalyticList, error) {
	out := new(AnalyticList)
	err := c.cc.Invoke(ctx, "/mediforproto.Pipeline/GetAnalyticMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PipelineServer is the server API for Pipeline service.
type PipelineServer interface {
	Detect(context.Context, *DetectionRequest) (*DetectionInfo, error)
	GetDetectionInfo(context.Context, *DetectionInfoRequest) (*DetectionInfo, error)
	GetDetectionList(context.Context, *DetectionListRequest) (*DetectionList, error)
	DeleteDetection(context.Context, *DeleteDetectionRequest) (*Empty, error)
	Fuse(context.Context, *FusionRequest) (*FusionInfo, error)
	FuseByID(context.Context, *FusionRequest) (*FusionInfo, error)
	FuseAllIDs(context.Context, *FuseAllIDsRequest) (*FuseAllIDsResponse, error)
	UpdateDetectionTags(context.Context, *UpdateDetectionTagsRequest) (*DetectionInfo, error)
	GetDetectionTagInfo(context.Context, *DetectionTagInfoRequest) (*DetectionTagInfo, error)
	GetAnalyticMeta(context.Context, *Empty) (*AnalyticList, error)
}

// UnimplementedPipelineServer can be embedded to have forward compatible implementations.
type UnimplementedPipelineServer struct {
}

func (*UnimplementedPipelineServer) Detect(ctx context.Context, req *DetectionRequest) (*DetectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (*UnimplementedPipelineServer) GetDetectionInfo(ctx context.Context, req *DetectionInfoRequest) (*DetectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDetectionInfo not implemented")
}
func (*UnimplementedPipelineServer) GetDetectionList(ctx context.Context, req *DetectionListRequest) (*DetectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDetectionList not implemented")
}
func (*UnimplementedPipelineServer) DeleteDetection(ctx context.Context, req *DeleteDetectionRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDetection not implemented")
}
func (*UnimplementedPipelineServer) Fuse(ctx context.Context, req *FusionRequest) (*FusionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fuse not implemented")
}
func (*UnimplementedPipelineServer) FuseByID(ctx context.Context, req *FusionRequest) (*FusionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FuseByID not implemented")
}
func (*UnimplementedPipelineServer) FuseAllIDs(ctx context.Context, req *FuseAllIDsRequest) (*FuseAllIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FuseAllIDs not implemented")
}
func (*UnimplementedPipelineServer) UpdateDetectionTags(ctx context.Context, req *UpdateDetectionTagsRequest) (*DetectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDetectionTags not implemented")
}
func (*UnimplementedPipelineServer) GetDetectionTagInfo(ctx context.Context, req *DetectionTagInfoRequest) (*DetectionTagInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDetectionTagInfo not implemented")
}
func (*UnimplementedPipelineServer) GetAnalyticMeta(ctx context.Context, req *Empty) (*AnalyticList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnalyticMeta not implemented")
}

func RegisterPipelineServer(s *grpc.Server, srv PipelineServer) {
	s.RegisterService(&_Pipeline_serviceDesc, srv)
}

func _Pipeline_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).Detect(ctx, req.(*DetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionInfo(ctx, req.(*DetectionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionList(ctx, req.(*DetectionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_DeleteDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).DeleteDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/DeleteDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).DeleteDetection(ctx, req.(*DeleteDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_Fuse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).Fuse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/Fuse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).Fuse(ctx, req.(*FusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_FuseByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).FuseByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/FuseByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).FuseByID(ctx, req.(*FusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_FuseAllIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuseAllIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).FuseAllIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/FuseAllIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).FuseAllIDs(ctx, req.(*FuseAllIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_UpdateDetectionTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDetectionTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).UpdateDetectionTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/UpdateDetectionTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).UpdateDetectionTags(ctx, req.(*UpdateDetectionTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetDetectionTagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectionTagInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetDetectionTagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetDetectionTagInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetDetectionTagInfo(ctx, req.(*DetectionTagInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pipeline_GetAnalyticMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServer).GetAnalyticMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mediforproto.Pipeline/GetAnalyticMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServer).GetAnalyticMeta(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pipeline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mediforproto.Pipeline",
	HandlerType: (*PipelineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Detect",
			Handler:    _Pipeline_Detect_Handler,
		},
		{
			MethodName: "GetDetectionInfo",
			Handler:    _Pipeline_GetDetectionInfo_Handler,
		},
		{
			MethodName: "GetDetectionList",
			Handler:    _Pipeline_GetDetectionList_Handler,
		},
		{
			MethodName: "DeleteDetection",
			Handler:    _Pipeline_DeleteDetection_Handler,
		},
		{
			MethodName: "Fuse",
			Handler:    _Pipeline_Fuse_Handler,
		},
		{
			MethodName: "FuseByID",
			Handler:    _Pipeline_FuseByID_Handler,
		},
		{
			MethodName: "FuseAllIDs",
			Handler:    _Pipeline_FuseAllIDs_Handler,
		},
		{
			MethodName: "UpdateDetectionTags",
			Handler:    _Pipeline_UpdateDetectionTags_Handler,
		},
		{
			MethodName: "GetDetectionTagInfo",
			Handler:    _Pipeline_GetDetectionTagInfo_Handler,
		},
		{
			MethodName: "GetAnalyticMeta",
			Handler:    _Pipeline_GetAnalyticMeta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "medifor/v1/pipeline.proto",
}
