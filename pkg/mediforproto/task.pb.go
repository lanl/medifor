// Code generated by protoc-gen-go. DO NOT EDIT.
// source: medifor/v1/task.proto

package mediforproto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// DetectionTask contains a Detection (partial - holding only the
// request) and enough surrounding machinery to allow workflow tasks to
// maintain state in a larger system.
// Next Tag: 10
type DetectionTask struct {
	// An identifier that uniquely represents this particular detection task.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Analytics to run this detection on. When a single analytic receives a task
	// like this, there will only be one value in this field. When pushing a
	// completed task, this ID should be preserved so that proper attribution
	// occurs.
	AnalyticId []string `protobuf:"bytes,2,rep,name=analytic_id,json=analyticId,proto3" json:"analytic_id,omitempty"`
	// Fusers to run when all analytics are finished for this detection.
	// Can be empty, in which case no fusion will be triggered on completion.
	FuserId []string `protobuf:"bytes,9,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// A partial detection, containing an incomplete request (can be missing the
	// request ID, for example) with just enough information in it to pass it on
	// to an analytic.
	Detection *Detection `protobuf:"bytes,3,opt,name=detection,proto3" json:"detection,omitempty"`
	// The queue into which a response should be inserted when this task is
	// either finished or has encountered a permanent error.
	DoneQueue string `protobuf:"bytes,4,opt,name=done_queue,json=doneQueue,proto3" json:"done_queue,omitempty"`
	// System tags for grouping things. Use user_tags if you aren't sure which
	// one to use.
	Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// User tags.
	UserTags map[string]string `protobuf:"bytes,7,rep,name=user_tags,json=userTags,proto3" json:"user_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Metadata table.
	Meta map[string]string `protobuf:"bytes,8,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Timeout in seconds after which an analytic worker will die waiting for the
	// analytic to respond. Default is "no timeout" (0 seconds).
	AnalyticTimeoutSec   int64    `protobuf:"varint,6,opt,name=analytic_timeout_sec,json=analyticTimeoutSec,proto3" json:"analytic_timeout_sec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetectionTask) Reset()         { *m = DetectionTask{} }
func (m *DetectionTask) String() string { return proto.CompactTextString(m) }
func (*DetectionTask) ProtoMessage()    {}
func (*DetectionTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe6fd396ef9e302f, []int{0}
}

func (m *DetectionTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectionTask.Unmarshal(m, b)
}
func (m *DetectionTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectionTask.Marshal(b, m, deterministic)
}
func (m *DetectionTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectionTask.Merge(m, src)
}
func (m *DetectionTask) XXX_Size() int {
	return xxx_messageInfo_DetectionTask.Size(m)
}
func (m *DetectionTask) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectionTask.DiscardUnknown(m)
}

var xxx_messageInfo_DetectionTask proto.InternalMessageInfo

func (m *DetectionTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectionTask) GetAnalyticId() []string {
	if m != nil {
		return m.AnalyticId
	}
	return nil
}

func (m *DetectionTask) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *DetectionTask) GetDetection() *Detection {
	if m != nil {
		return m.Detection
	}
	return nil
}

func (m *DetectionTask) GetDoneQueue() string {
	if m != nil {
		return m.DoneQueue
	}
	return ""
}

func (m *DetectionTask) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DetectionTask) GetUserTags() map[string]string {
	if m != nil {
		return m.UserTags
	}
	return nil
}

func (m *DetectionTask) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DetectionTask) GetAnalyticTimeoutSec() int64 {
	if m != nil {
		return m.AnalyticTimeoutSec
	}
	return 0
}

// Next ID: 8
type FusionTask struct {
	// Unique identifier for the fusion task
	UnusedId string `protobuf:"bytes,1,opt,name=unused_id,json=unusedId,proto3" json:"unused_id,omitempty"`
	// Fusion algorithms to run this fusion on.
	FuserId []string `protobuf:"bytes,2,rep,name=fuser_id,json=fuserId,proto3" json:"fuser_id,omitempty"`
	// A partial fusion (request filled out, requestID may be missing)
	Fusion *Fusion `protobuf:"bytes,3,opt,name=fusion,proto3" json:"fusion,omitempty"`
	// The queue into which a response is inserted when this task has completed or
	// encountered a permanent error
	DoneQueue string `protobuf:"bytes,4,opt,name=done_queue,json=doneQueue,proto3" json:"done_queue,omitempty"`
	// Tag map
	Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Timeout in seconds after which an analytic worker will die waiting for the
	// analytic to respond. Default is "no timeout" (0 seconds).
	AnalyticTimeoutSec int64 `protobuf:"varint,6,opt,name=analytic_timeout_sec,json=analyticTimeoutSec,proto3" json:"analytic_timeout_sec,omitempty"`
	// detection_id for the detections to be fused.  Required for database writes
	DetectionId          string   `protobuf:"bytes,7,opt,name=detection_id,json=detectionId,proto3" json:"detection_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FusionTask) Reset()         { *m = FusionTask{} }
func (m *FusionTask) String() string { return proto.CompactTextString(m) }
func (*FusionTask) ProtoMessage()    {}
func (*FusionTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe6fd396ef9e302f, []int{1}
}

func (m *FusionTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FusionTask.Unmarshal(m, b)
}
func (m *FusionTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FusionTask.Marshal(b, m, deterministic)
}
func (m *FusionTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FusionTask.Merge(m, src)
}
func (m *FusionTask) XXX_Size() int {
	return xxx_messageInfo_FusionTask.Size(m)
}
func (m *FusionTask) XXX_DiscardUnknown() {
	xxx_messageInfo_FusionTask.DiscardUnknown(m)
}

var xxx_messageInfo_FusionTask proto.InternalMessageInfo

func (m *FusionTask) GetUnusedId() string {
	if m != nil {
		return m.UnusedId
	}
	return ""
}

func (m *FusionTask) GetFuserId() []string {
	if m != nil {
		return m.FuserId
	}
	return nil
}

func (m *FusionTask) GetFusion() *Fusion {
	if m != nil {
		return m.Fusion
	}
	return nil
}

func (m *FusionTask) GetDoneQueue() string {
	if m != nil {
		return m.DoneQueue
	}
	return ""
}

func (m *FusionTask) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FusionTask) GetAnalyticTimeoutSec() int64 {
	if m != nil {
		return m.AnalyticTimeoutSec
	}
	return 0
}

func (m *FusionTask) GetDetectionId() string {
	if m != nil {
		return m.DetectionId
	}
	return ""
}

func init() {
	proto.RegisterType((*DetectionTask)(nil), "mediforproto.DetectionTask")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionTask.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionTask.TagsEntry")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.DetectionTask.UserTagsEntry")
	proto.RegisterType((*FusionTask)(nil), "mediforproto.FusionTask")
	proto.RegisterMapType((map[string]string)(nil), "mediforproto.FusionTask.TagsEntry")
}

func init() { proto.RegisterFile("medifor/v1/task.proto", fileDescriptor_fe6fd396ef9e302f) }

var fileDescriptor_fe6fd396ef9e302f = []byte{
	// 429 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x52, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x95, 0xed, 0x34, 0xc9, 0x4e, 0x5a, 0x84, 0x56, 0x41, 0xdd, 0x1a, 0x21, 0x4c, 0x24, 0x24,
	0x23, 0x21, 0x17, 0x8a, 0xa0, 0x7c, 0x5c, 0xa1, 0x52, 0x0e, 0x1c, 0x30, 0xe1, 0x6c, 0x2d, 0xde,
	0x49, 0xb5, 0x4a, 0x63, 0x83, 0x77, 0xb7, 0x52, 0xfe, 0x25, 0x37, 0xfe, 0x0e, 0xda, 0xf5, 0x47,
	0x63, 0x54, 0x88, 0xd2, 0x9b, 0xe7, 0xbd, 0x79, 0xe3, 0x37, 0x3b, 0x0f, 0x1e, 0xac, 0x51, 0xc8,
	0x65, 0x59, 0x9d, 0x5e, 0xbf, 0x3c, 0xd5, 0x5c, 0xad, 0x92, 0x1f, 0x55, 0xa9, 0x4b, 0x7a, 0xd8,
	0xc0, 0xae, 0x0a, 0x4f, 0xb6, 0x9a, 0x78, 0xc1, 0xaf, 0x36, 0x5a, 0xe6, 0x75, 0x63, 0x78, 0xbc,
	0x45, 0x2d, 0x8d, 0x92, 0x65, 0x51, 0x13, 0xb3, 0x5f, 0x03, 0x38, 0xfa, 0x88, 0x1a, 0x73, 0x2d,
	0xcb, 0x62, 0xc1, 0xd5, 0x8a, 0xde, 0x03, 0x5f, 0x0a, 0xe6, 0x45, 0x5e, 0x4c, 0x52, 0x5f, 0x0a,
	0xfa, 0x18, 0x26, 0xed, 0xb0, 0x4c, 0x0a, 0xe6, 0x47, 0x41, 0x4c, 0x52, 0x68, 0xa1, 0xb9, 0xa0,
	0x27, 0x30, 0x5e, 0x1a, 0x85, 0x95, 0x65, 0x89, 0x63, 0x47, 0xae, 0x9e, 0x0b, 0xfa, 0x1a, 0x88,
	0x68, 0x87, 0xb3, 0x20, 0xf2, 0xe2, 0xc9, 0xd9, 0x71, 0xb2, 0xed, 0x39, 0xe9, 0xfe, 0x9d, 0xde,
	0x74, 0xd2, 0x47, 0x00, 0xa2, 0x2c, 0x30, 0xfb, 0x69, 0xd0, 0x20, 0x1b, 0x38, 0x2b, 0xc4, 0x22,
	0x5f, 0x2c, 0x40, 0xdf, 0xc1, 0x40, 0xf3, 0x4b, 0xc5, 0x0e, 0xa2, 0x20, 0x9e, 0x9c, 0x3d, 0xfd,
	0xc7, 0x40, 0xbb, 0x4c, 0xb2, 0xe0, 0x97, 0xea, 0x53, 0xa1, 0xab, 0x4d, 0xea, 0x24, 0xf4, 0x02,
	0x88, 0xb3, 0xea, 0xf4, 0x23, 0xa7, 0x7f, 0xf6, 0x3f, 0xfd, 0x37, 0x85, 0xd5, 0xcd, 0x8c, 0xb1,
	0x69, 0x4a, 0x6b, 0x61, 0x8d, 0x9a, 0xb3, 0xf1, 0x6e, 0x0b, 0x9f, 0x51, 0xf3, 0xc6, 0x82, 0x95,
	0xd0, 0x17, 0x30, 0xed, 0xde, 0x53, 0xcb, 0x35, 0x96, 0x46, 0x67, 0x0a, 0x73, 0x36, 0x8c, 0xbc,
	0x38, 0x48, 0x69, 0xcb, 0x2d, 0x6a, 0xea, 0x2b, 0xe6, 0xe1, 0x39, 0x90, 0xce, 0x03, 0xbd, 0x0f,
	0xc1, 0x0a, 0x37, 0xcd, 0x7d, 0xec, 0x27, 0x9d, 0xc2, 0xc1, 0x35, 0xbf, 0x32, 0xc8, 0x7c, 0x87,
	0xd5, 0xc5, 0x7b, 0xff, 0xad, 0x17, 0x7e, 0x80, 0xa3, 0xde, 0x02, 0x7b, 0x89, 0xcf, 0x81, 0x74,
	0xd6, 0xf7, 0x11, 0xce, 0x7e, 0xfb, 0x00, 0x17, 0x2e, 0x63, 0x2e, 0x4f, 0x0f, 0x81, 0x98, 0xc2,
	0x28, 0x14, 0x59, 0x17, 0xab, 0x71, 0x0d, 0xfc, 0x95, 0x1d, 0xbf, 0x9f, 0x9d, 0xe7, 0x30, 0xac,
	0x93, 0xda, 0x04, 0x67, 0xda, 0x7f, 0xe4, 0xfa, 0x0f, 0x69, 0xd3, 0xb3, 0x2b, 0x32, 0x6f, 0x7a,
	0x91, 0x99, 0xdd, 0x36, 0xea, 0xd6, 0xbc, 0xec, 0x7d, 0x2c, 0xfa, 0x04, 0x0e, 0xbb, 0x20, 0xdb,
	0xad, 0x46, 0xce, 0xca, 0xa4, 0xc3, 0xe6, 0xe2, 0xce, 0xf7, 0xfc, 0x3e, 0x74, 0x7e, 0x5f, 0xfd,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x38, 0xa4, 0x12, 0xbf, 0x0e, 0x04, 0x00, 0x00,
}
